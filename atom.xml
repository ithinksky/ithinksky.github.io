<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星月楼阁</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ithinksky.com/"/>
  <updated>2020-12-17T09:40:24.046Z</updated>
  <id>https://blog.ithinksky.com/</id>
  
  <author>
    <name>tengpeng.gao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【逻辑推理】之001拿球问题</title>
    <link href="https://blog.ithinksky.com/2020/12/17/%E3%80%90%E9%80%BB%E8%BE%91%E6%8E%A8%E7%90%86%E3%80%91%E4%B9%8B001%E6%8B%BF%E7%90%83%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.ithinksky.com/2020/12/17/【逻辑推理】之001拿球问题/</id>
    <published>2020-12-16T16:00:00.000Z</published>
    <updated>2020-12-17T09:40:24.046Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><h1 id="拿球问题"><a class="markdownIt-Anchor" href="#拿球问题"></a> 拿球问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题描述：假设排列着100个乒乓球，由两个人轮流拿球装入口袋，能拿到第100个乒乓球的人为胜利者。</span><br><span class="line">条件是：每次拿球者至少要拿1个，但最多不能超过5个，</span><br><span class="line">问：如果你是最先拿球的人，你该拿几个？以后怎么拿就能保证你能得到第100个乒乓球？</span><br></pre></td></tr></table></figure><pre><code>要想拿到第100个球，那么在上一轮的拿球中，就必须拿到第94个球；要想拿到第94个球，那么在上一轮的拿球中，就必须拿到第88个球；要想拿到第88个球，那么在上一轮的拿球中，就必须拿到第82个球；…………由于100=6*16+4，那么由此推测，在第一轮拿球过程中，必须拿4个；在以后的拿球中必须保证拿到第10,16，……，4+6*a个球，其中1&lt;a&lt;=16.</code></pre><hr><h1 id="拿球问题变式"><a class="markdownIt-Anchor" href="#拿球问题变式"></a> 拿球问题变式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题描述：假设排列着100个乒乓球，由两个人轮流拿球装入口袋，能拿到第100个乒乓球的人为胜利者。</span><br><span class="line">条件是：每次拿球者至少要拿1个，A 只能拿1，2，3个，B只能拿1，2个，</span><br><span class="line">问：如果A是最先拿球的人，以后怎么拿就能保证A能得到第100个乒乓球？</span><br></pre></td></tr></table></figure><pre><code>每回合拿球都是3的倍数，那么最后一回合时还有1个球，由于A先拿，所以A必能拿到第100个球。</code></pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;拿球问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#拿球问题&quot;&gt;&lt;/a&gt; 拿球问题&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
      <category term="逻辑推理" scheme="https://blog.ithinksky.com/categories/%E9%80%BB%E8%BE%91%E6%8E%A8%E7%90%86/"/>
    
    
      <category term="逻辑推理" scheme="https://blog.ithinksky.com/tags/%E9%80%BB%E8%BE%91%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【JDK1.8】java.lang.ref 包</title>
    <link href="https://blog.ithinksky.com/2020/08/14/%E3%80%90jdk1-8%E3%80%91java-lang-ref-%E5%8C%85/"/>
    <id>https://blog.ithinksky.com/2020/08/14/【jdk1-8】java-lang-ref-包/</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-11-14T15:17:17.346Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><h1 id="javalangref-包"><a class="markdownIt-Anchor" href="#javalangref-包"></a> java.lang.ref 包</h1><p><a href="https://github.com/ithinksky/java-base-bucket" target="_blank" rel="noopener">【JDK1.8案例源码】</a></p><blockquote><p>Java.lang.ref 是 Java 类库中比较特殊的一个包，它提供了与 Java 垃圾回收器密切相关的引用类。</p></blockquote><blockquote><p>reference objects are implemented in close cooperation with the garbage collector</p></blockquote><h2 id="包内结构"><a class="markdownIt-Anchor" href="#包内结构"></a> 包内结构</h2><p><img src="/images/jdk1.8/ref/project.png" alt="java.lang.ref 包"></p><h2 id="类图"><a class="markdownIt-Anchor" href="#类图"></a> 类图</h2><p><img src="/images/jdk1.8/ref/uml.png" alt="java.lang.ref 包"></p><blockquote><p>Reference 是一个抽象类，而 SoftReference，WeakReference，PhantomReference 以及 FinalReference 都是继承它的具体类。</p></blockquote><h1 id="reference-特性及用法"><a class="markdownIt-Anchor" href="#reference-特性及用法"></a> Reference 特性及用法</h1><h2 id="strongreference"><a class="markdownIt-Anchor" href="#strongreference"></a> StrongReference</h2><blockquote><p>我们都知道 JVM 中对象是被分配在堆（heap）上的，当程序行动中不再有引用指向这个对象时，<br>这个对象就可以被垃圾回收器所回收。这里所说的引用也就是我们一般意义上申明的对象类型的变量（如 String, Object, ArrayList 等），<br>区别于原始数据类型的变量（如 int, short, long 等）也称为强引用。在了解虚引用之前，我们一般都是使用强引用来对对象进行引用。如：</p></blockquote><p>清单 1. StrongReference usage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String tag = new String(&quot;T&quot;);</span><br></pre></td></tr></table></figure><p>此处的 tag 引用就称之为强引用。而强引用有以下特征：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收。</li><li>强引用可能导致内存泄漏。</li></ul><p>我们要讨论的这三种 Reference 较之于强引用而言都属于”弱引用”，也就是他们所引用的对象只要没有强引用，<br>就会根据条件被 JVM 的垃圾回收器所回收，它们被回收的时机以及用法各不相同。下面分别来进行讨论。</p><h2 id="softreference"><a class="markdownIt-Anchor" href="#softreference"></a> SoftReference</h2><blockquote><p>SoftReference 在”弱引用”中属于最强的引用。SoftReference 所指向的对象，当没有强引用指向它时，会在内存中停留一段的时间，<br>垃圾回收器会根据 JVM 内存的使用情况（内存的紧缺程度）以及 SoftReference 的 get() 方法的调用情况来决定是否对其进行回收。</p></blockquote><blockquote><p>具体使用一般是通过 SoftReference 的构造方法，将需要用弱引用来指向的对象包装起来。<br>当需要使用的时候，调用 SoftReference 的 get() 方法来获取。<br>当对象未被回收时 SoftReference 的 get() 方法会返回该对象的强引用。如下：</p></blockquote><p>清单 2. SoftReference usage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SoftReference&lt;Bean&gt; bean = new SoftReference&lt;Bean&gt;(new Bean(&quot;name&quot;, 10));</span><br><span class="line">System.out.println(bean.get());// &quot;name:10”</span><br></pre></td></tr></table></figure><p>软引用有以下特征：</p><ul><li>软引用使用 get() 方法取得对象的强引用从而访问目标对象。</li><li>软引用所指向的对象按照 JVM 的使用情况（Heap 内存是否临近阈值）来决定是否回收。</li><li>软引用可以避免 Heap 内存不足所导致的异常。</li></ul><blockquote><p>当垃圾回收器决定对其回收时，会先清空它的 SoftReference，也就是说 SoftReference 的 get() 方法将会返回 null，<br>然后再调用对象的 finalize() 方法，并在下一轮 GC 中对其真正进行回收。</p></blockquote><h2 id="weakreference"><a class="markdownIt-Anchor" href="#weakreference"></a> WeakReference</h2><blockquote><p>WeakReference 是弱于 SoftReference 的引用类型。弱引用的特性和基本与软引用相似，<br>区别就在于弱引用所指向的对象只要进行系统垃圾回收，不管内存使用情况如何，永远对其进行回收（get() 方法返回 null）。<br>完全可以通过和 SoftReference 一样的方式来操作 WeakReference，这里就不再复述。</p></blockquote><p>弱引用有以下特征：</p><ul><li>弱引用使用 get() 方法取得对象的强引用从而访问目标对象。</li><li>一旦系统内存回收，无论内存是否紧张，弱引用指向的对象都会被回收。</li><li>弱引用也可以避免 Heap 内存不足所导致的异常。</li></ul><h2 id="phantomreference"><a class="markdownIt-Anchor" href="#phantomreference"></a> PhantomReference</h2><blockquote><p>PhantomReference 是所有”弱引用”中最弱的引用类型。不同于软引用和弱引用，<br>虚引用无法通过 get() 方法来取得目标对象的强引用从而使用目标对象，观察源码可以发现 get() 被重写为永远返回 null。</p></blockquote><blockquote><p>那虚引用到底有什么作用？其实虚引用主要被用来 跟踪对象被垃圾回收的状态 ，<br>通过查看引用队列中是否包含对象所对应的虚引用来判断它是否 即将 被垃圾回收，从而采取行动。<br>它并不被期待用来取得目标对象的引用，而目标对象被回收前，它的引用会被放入一个 ReferenceQueue 对象中，从而达到跟踪对象垃圾回收的作用。</p></blockquote><p>所以具体用法和之前两个有所不同，它必须传入一个 ReferenceQueue 对象。当虚引用所引用对象被垃圾回收后，虚引用会被添加到这个队列中。如：</p><p>清单 3. PhantomReference usage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ReferenceQueue&lt;String&gt; refQueue = new ReferenceQueue&lt;String&gt;();</span><br><span class="line">    PhantomReference&lt;String&gt; referent = new PhantomReference&lt;String&gt;(new String(&quot;T&quot;), refQueue);</span><br><span class="line">    System.out.println(referent.get());// null</span><br><span class="line"></span><br><span class="line">    System.gc();</span><br><span class="line">    System.runFinalization();</span><br><span class="line"></span><br><span class="line">    System.out.println(refQueue.poll() == referent); //true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是，对于引用回收方面，虚引用类似强引用不会自动根据内存情况自动对目标对象回收，<br>Client 需要自己对其进行处理以防 Heap 内存不足异常。</p></blockquote><p>虚引用有以下特征：</p><ul><li>虚引用永远无法使用 get() 方法取得对象的强引用从而访问目标对象。</li><li>虚引用所指向的对象在被系统内存回收前，虚引用自身会被放入 ReferenceQueue 对象中从而跟踪对象垃圾回收。</li><li>虚引用不会根据内存情况自动回收目标对象。</li></ul><blockquote><p>另外值得注意的是，其实 SoftReference, WeakReference 以及 PhantomReference 的构造函数都可以接收一个 ReferenceQueue 对象。<br>当 SoftReference 以及 WeakReference 被清空的同时，也就是 Java 垃圾回收器准备对它们所指向的对象进行回收时，调用对象的 finalize() 方法之前，<br>它们自身会被加入到这个 ReferenceQueue 对象 中，此时可以通过 ReferenceQueue 的 poll() 方法取到它们。<br>而 PhantomReference 只有当 Java 垃圾回收器对其所指向的对象真正进行回收时，会将其加入到这个 ReferenceQueue 对象 中，这样就可以追综对象的销毁情况。</p></blockquote><h1 id="各种引用类型总结"><a class="markdownIt-Anchor" href="#各种引用类型总结"></a> 各种引用类型总结</h1><h2 id="表-1-引用类型特性总结"><a class="markdownIt-Anchor" href="#表-1-引用类型特性总结"></a> 表 1. 引用类型特性总结</h2><table><thead><tr><th>引用类型</th><th>取得目标对象方式</th><th>垃圾回收条件</th><th>是否可能内存泄漏</th></tr></thead><tbody><tr><td>强引用</td><td>直接调用</td><td>不回收</td><td>可能</td></tr><tr><td>软引用</td><td>通过 get() 方法</td><td>视内存情况回收</td><td>可能</td></tr><tr><td>弱引用</td><td>通过 get() 方法</td><td>永远回收</td><td>可能</td></tr><tr><td>虚引用</td><td>无法取得</td><td>不回收</td><td>可能</td></tr></tbody></table><pre><code>注意：    如果想使用这些相对强引用来说较弱的引用来进行对象操作的时候，    就必须保证没有强引用指向被操作对象。否则将会被视为强引用指向，    不会具有任何的弱引用的特性。</code></pre><h2 id="表-2各个引用在-gc-后是否被回收"><a class="markdownIt-Anchor" href="#表-2各个引用在-gc-后是否被回收"></a> 表 2：各个引用在 GC 后是否被回收？</h2><table><thead><tr><th>引用类型</th><th>GC 后是否回收</th></tr></thead><tbody><tr><td>强引用</td><td>不回收</td></tr><tr><td>软引用</td><td>视内存情况回收</td></tr><tr><td>弱引用</td><td>永远回收</td></tr><tr><td>虚引用</td><td>不回收</td></tr></tbody></table><h2 id="表-3各个引用创建大量对象时是否导致-heap-不足异常"><a class="markdownIt-Anchor" href="#表-3各个引用创建大量对象时是否导致-heap-不足异常"></a> 表 3：各个引用创建大量对象时是否导致 Heap 不足异常？</h2><table><thead><tr><th>引用类型</th><th>是否抛出异常</th></tr></thead><tbody><tr><td>强引用</td><td>直接调用</td></tr><tr><td>软引用</td><td>通过 get() 方法</td></tr><tr><td>弱引用</td><td>通过 get() 方法</td></tr><tr><td>虚引用</td><td>无法取得</td></tr></tbody></table><h1 id="finalreference-以及-finzlizer"><a class="markdownIt-Anchor" href="#finalreference-以及-finzlizer"></a> FinalReference 以及 Finzlizer</h1><pre><code>FinalReference 作为 java.lang.ref 里的一个不能被公开访问的类，又起到了一个什么样的作用呢？作为他的子类，Finalizer 又在垃圾回收机制里扮演了怎么样的角色呢？</code></pre><p>实际上，FinalReference 代表的正是 Java 中的强引用，如这样的代码 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bean bean = new Bean();</span><br></pre></td></tr></table></figure><p>在虚拟机的实现过程中，实际采用了 FinalReference 类对其进行引用。而 Finalizer，除了作为一个实现类外，<br>更是在虚拟机中实现一个 FinalizerThread，以使虚拟机能够在所有的强引用被解除后实现内存清理。</p><p>让我们来看看 Finalizer 是如何工作的。首先，通过声明 FinalizerThread，并将该线程实例化，设置为守护线程后，加入系统线程中去。</p><p>在 GC 的过程中，当一个强引用被释放，由系统垃圾收集器标记后的对象，会被加入 Finalizer 对象中的 ReferenceQueue 中去，<br>并调用 Finalizer.runFinalizer() 来执行对象的 finalize 方法。</p><p>注意，<br>标记处所调用的 invokeFinalizeMethod 为 native 方法，由于 finalize 方法在 Object 类中被声明为 protected，<br>这里必须采用 native 方法才能调用。随后通过将本地强引用设置为空，以便使垃圾回收器清理内存。</p><p>可以看到，通过这样的方法，Java 将四种引用对象类型：<br>软引用 (SoftReference)，弱引用 (WeakReference)，强引用 (FinalReference)，虚引用 (PhantomReference) 平等地对待，<br>并在垃圾回收器中进行统一调度和管理。</p><h1 id="回顾"><a class="markdownIt-Anchor" href="#回顾"></a> 回顾</h1><ul><li>软引用 (SoftReference)<br>引用类型表现为当内存接近满负荷 , 或对象由 SoftReference.get() 方法的调用没有发生一段时间后 , 垃圾回收器将会清理该对象 . 在运行对象的 finalize 方法前 , 会将软引用对象加入 ReferenceQueue 中去 .</li><li>弱引用 (WeakReference)<br>引用类型表现为当系统垃圾回收器开始回收时 , 则立即会回收该对象的引用 . 与软引用一样 , 弱引用也会在运行对象的 finalize 方法之前将弱引用对象加入 ReferenceQueue.</li><li>强引用 (FinalReference)<br>这是最常用的引用类型 . JVM 系统采用 Finalizer 来管理每个强引用对象 , 并将其被标记要清理时加入 ReferenceQueue, 并逐一调用该对象的 finalize() 方法 .</li><li>虚引用 (PhantomReference)<br>这是一个最虚幻的引用类型 . 无论是从哪里都无法再次返回被虚引用所引用的对象 . 虚引用在系统垃圾回收器开始回收对象时 , 将直接调用 finalize() 方法 , 但不会立即将其加入回收队列 . 只有在真正对象被 GC 清除时 , 才会将其加入 Reference 队列中去 .</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://developer.ibm.com/zh/articles/j-lo-langref/" target="_blank" rel="noopener">深入探讨 java.lang.ref 包</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;javalangref-包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#javalangref-包&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="JDK1.8" scheme="https://blog.ithinksky.com/categories/JDK1-8/"/>
    
    
      <category term="JDK1.8" scheme="https://blog.ithinksky.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>【重温设计模式】之005单例模式</title>
    <link href="https://blog.ithinksky.com/2020/06/18/%E3%80%90%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%B9%8B005%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ithinksky.com/2020/06/18/【重温设计模式】之005单例模式/</id>
    <published>2020-06-17T16:00:00.000Z</published>
    <updated>2020-11-14T15:17:17.345Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><p><a href="https://github.com/ithinksky/java-patterns" target="_blank" rel="noopener">【重温设计模式系列源码】</a></p><blockquote><p>单例模式</p></blockquote><h1 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h1><h2 id="含义"><a class="markdownIt-Anchor" href="#含义"></a> 含义</h2><blockquote><p>一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。<br>这个类提供了一种访问其唯一的对象的方式，<br>访问者可以直接访问，不需要实例化该类的对象。</p></blockquote><h2 id="解决的问题"><a class="markdownIt-Anchor" href="#解决的问题"></a> 解决的问题</h2><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>一个全局使用的类频繁地创建与销毁。</p></blockquote><h2 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h2><ul><li>单例类只能有一个实例</li></ul><blockquote><p>类对象的实例数： 0 ~ 1</p></blockquote><ul><li>单例类必须自己创建自己的唯一实例</li></ul><blockquote><p>类的构造方法：私有构造方法。</p></blockquote><ul><li>单例类必须给所有其他对象提供这一实例</li></ul><blockquote><p>提供唯一的访问该对象实例的方法。</p></blockquote><h2 id="uml类图"><a class="markdownIt-Anchor" href="#uml类图"></a> UML类图</h2><blockquote><p><img src="/images/designpattern/t05singleton/uml.png" alt="单例模式UML类图"></p></blockquote><h2 id="使用步骤"><a class="markdownIt-Anchor" href="#使用步骤"></a> 使用步骤</h2><ol><li>访问唯一的访问该对象实例的方法</li></ol><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><ul><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><ul><li>没有接口，不能继承，违背了单一职责原则</li><li>一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li></ul><h2 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h2><ul><li>要求生产唯一序列号。</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><blockquote><p>尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；<br>所谓原则，只是为了更好地为我们服务；<br>具体如何应用需要我们在业务实践中灵活把控。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ithinksky/java-patterns&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="重温设计模式" scheme="https://blog.ithinksky.com/categories/%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.ithinksky.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【重温设计模式】之004抽象工厂模式</title>
    <link href="https://blog.ithinksky.com/2020/06/17/%E3%80%90%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%B9%8B004%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ithinksky.com/2020/06/17/【重温设计模式】之004抽象工厂模式/</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2020-11-14T15:17:17.344Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><p><a href="https://github.com/ithinksky/java-patterns" target="_blank" rel="noopener">【重温设计模式系列源码】</a></p><blockquote><p>抽象工厂模式</p></blockquote><h1 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h1><h2 id="含义"><a class="markdownIt-Anchor" href="#含义"></a> 含义</h2><blockquote><p>抽象工厂模式，即Abstract Factory Pattern，提供一个创建一<code>系列</code>相关或相互依赖对象的接口，<br>而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。</p></blockquote><h2 id="解决的问题"><a class="markdownIt-Anchor" href="#解决的问题"></a> 解决的问题</h2><blockquote><p>即工厂方法模式的缺点: 每个工厂只能创建一类产品</p></blockquote><h2 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h2><table><thead><tr><th>组成</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品（IProduct）</td><td>产品顶级抽象父类</td><td>描述产品的公共接口</td></tr><tr><td>抽象子产品（IxxProduct）</td><td>具体产品类的父类，顶级抽象父类的子类</td><td>描述相对具体的抽象产品的公共接口</td></tr><tr><td>具体产品（XxProduct）</td><td>具体产品类，抽象父类的子类</td><td>描述具体的产品</td></tr><tr><td>抽象工厂（Factory）</td><td>具体工厂的父类</td><td>描述工厂的公共接口</td></tr><tr><td>具体工厂（XxFactory）</td><td>具体工厂类，抽象工厂的子类</td><td>描述具体工厂</td></tr></tbody></table><h2 id="uml类图"><a class="markdownIt-Anchor" href="#uml类图"></a> UML类图</h2><blockquote><p><img src="/images/designpattern/t04abstractfactory/uml.png" alt="抽象工厂模式UML类图"></p></blockquote><h2 id="使用步骤"><a class="markdownIt-Anchor" href="#使用步骤"></a> 使用步骤</h2><ol><li>创建产品标准</li><li>创建产品抽象类（一系列相关的产品）</li><li>创建具体产品类</li><li>创建工厂标准</li><li>创建生产具体产品的工厂</li></ol><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><ul><li>低耦合</li></ul><blockquote><p>将具体产品的创建延迟到子类。</p></blockquote><ul><li>更符合开闭原则</li></ul><blockquote><p>新增系列相关产品时，只需要增加具体的工厂和工厂需要生产的具体产品即可。</p></blockquote><ul><li>符合单一职责原则，</li></ul><blockquote><p>每个具体工厂类只负责创建对应的产品</p></blockquote><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><blockquote><p>抽象工厂模式很难支持新种类产品的变化。<br>这是因为抽象工厂接口中已经确定了可以被创建的产品集合，<br>如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，<br>这样也就违背了“开发——封闭”原则。</p></blockquote><h2 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h2><ul><li>一个系统不依赖产品类实例的创建和组合。</li><li>这个系统有多个系列的产品，而系统中只能消费其中的一系列产品。</li><li>系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。</li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><blockquote><p>尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；<br>所谓原则，只是为了更好地为我们服务；<br>具体如何应用需要我们在业务实践中灵活把控。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ithinksky/java-patterns&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="重温设计模式" scheme="https://blog.ithinksky.com/categories/%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.ithinksky.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【重温设计模式】之003工厂方法模式</title>
    <link href="https://blog.ithinksky.com/2020/06/10/%E3%80%90%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%B9%8B003%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ithinksky.com/2020/06/10/【重温设计模式】之003工厂方法模式/</id>
    <published>2020-06-09T16:00:00.000Z</published>
    <updated>2020-11-14T15:17:17.344Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><p><a href="https://github.com/ithinksky/java-patterns" target="_blank" rel="noopener">【重温设计模式系列源码】</a></p><blockquote><p>工厂方法模式</p></blockquote><h1 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h1><h2 id="含义"><a class="markdownIt-Anchor" href="#含义"></a> 含义</h2><blockquote><p>工厂方法模式又称为工厂模式、多态工厂模式和虚拟构造器模式。<br>通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。</p></blockquote><h2 id="解决的问题"><a class="markdownIt-Anchor" href="#解决的问题"></a> 解决的问题</h2><blockquote><p>即简单工厂模式的缺点<br>工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则</p></blockquote><p>言外意：</p><blockquote><p>工厂标准有了，产品标准有了，要想生产新的商品，需要开辟新的工厂生产新的商品。<br>虽然解决了简单工厂模式的“开闭原则”问题，但同时增加了额外开销。</p></blockquote><blockquote><p>简单工厂模式 是一个单一的工厂，如果需要提供新的产品，需要将工厂进行改造，<br>可以认为需要扩展一条流水线. 资源利用率的把控 凡事皆有度。</p></blockquote><h2 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h2><table><thead><tr><th>组成</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>产品标准</td><td>具体产品的父类</td><td>描述产品的公共接口</td></tr><tr><td>具体产品</td><td>产品标准的具体实现类</td><td>描述生产的具体产品</td></tr><tr><td>工厂标准</td><td>具体工厂的父类</td><td>描述工厂的公共接口</td></tr><tr><td>具体工厂</td><td>工厂标准的具体实现类</td><td>描述生产的具体产品的工厂</td></tr></tbody></table><h2 id="uml类图"><a class="markdownIt-Anchor" href="#uml类图"></a> UML类图</h2><p><img src="/images/designpattern/t03factorymethd/uml.png" alt="工厂方法模式UML类图"></p><h2 id="使用步骤"><a class="markdownIt-Anchor" href="#使用步骤"></a> 使用步骤</h2><ol><li>创建产品标准 （描述产品的公共接口）</li><li>创建具体产品类 （描述生产的具体产品）</li><li>创建工厂标准（描述工厂的公共接口）</li><li>创建具体工厂类（描述生产的具体产品的工厂）</li><li>外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</li></ol><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><ul><li>更符合开-闭原则</li></ul><blockquote><p>新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</p></blockquote><ul><li>符合单一职责原则</li></ul><blockquote><p>每个具体工厂类只负责创建对应的产品</p></blockquote><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><blockquote><p>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；<br>同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</p></blockquote><blockquote><p>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</p></blockquote><blockquote><p>一个具体工厂只能创建一种具体产品</p></blockquote><h2 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h2><ul><li>当一个类不知道它所需要的对象的类时</li></ul><blockquote><p>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</p></blockquote><ul><li>当一个类希望通过其子类来指定创建对象时</li></ul><blockquote><p>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，<br>利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p></blockquote><ul><li>灵活配置</li></ul><blockquote><p>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，<br>需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p></blockquote><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><blockquote><p>尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；<br>所谓原则，只是为了更好地为我们服务；<br>具体如何应用需要我们在业务实践中灵活把控。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ithinksky/java-patterns&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="重温设计模式" scheme="https://blog.ithinksky.com/categories/%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.ithinksky.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【重温设计模式】之002简单工厂模式</title>
    <link href="https://blog.ithinksky.com/2020/06/03/%E3%80%90%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%B9%8B002%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ithinksky.com/2020/06/03/【重温设计模式】之002简单工厂模式/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-11-14T15:17:17.343Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><p><a href="https://github.com/ithinksky/java-patterns" target="_blank" rel="noopener">【重温设计模式系列源码】</a></p><blockquote><p>简单工厂模式</p></blockquote><h1 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h1><h2 id="含义"><a class="markdownIt-Anchor" href="#含义"></a> 含义</h2><blockquote><p>简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法）。<br>在现实生活中，工厂是生产产品的，<br>同样的，在设计模式中，一个负责生产“对象”产品的类就是工厂类。</p></blockquote><h2 id="解决的问题"><a class="markdownIt-Anchor" href="#解决的问题"></a> 解决的问题</h2><blockquote><p>将 “类实例化的操作” 和 “使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类。</p></blockquote><p>言外意：</p><blockquote><p>将 铅笔的生产 和 使用铅笔 分开， 使用者只关注如何使用铅笔，而并不关注铅笔是如何生产的。</p></blockquote><blockquote><p>即使用者可直接消费产品而不需要知道其生产的细节。</p></blockquote><h2 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h2><table><thead><tr><th>组成</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>产品标准</td><td>具体产品的父类</td><td>描述产品的公共接口</td></tr><tr><td>具体产品</td><td>产品标准的具体实现类</td><td>描述生产的具体产品</td></tr><tr><td>工厂类</td><td>被外界调用</td><td>根据传入的不同参数而创建不同具体产品类的实例</td></tr></tbody></table><h2 id="uml类图"><a class="markdownIt-Anchor" href="#uml类图"></a> UML类图</h2><p><img src="/images/designpattern/t02simplefactory/uml.png" alt="简单工厂模式UML类图"></p><h2 id="使用步骤"><a class="markdownIt-Anchor" href="#使用步骤"></a> 使用步骤</h2><ol><li>创建产品标准 （描述产品的公共接口）</li><li>创建具体产品类 （描述生产的具体产品）</li><li>创建工厂类（通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例）</li><li>外界通过调用工厂类的静态方法，根据传入不同参数从而创建不同具体产品类的实例</li></ol><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><blockquote><p>将 创建产品的工作 与 使用产品的工作 分离开来，实现了解耦。<br>将 初始化实例的工作 放在了工厂类进行，容易进行维护。<br>面向接口编程，而不是面向对象。</p></blockquote><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><blockquote><p>工厂类集中了所有实例（产品）的创建逻辑，一旦工厂类不能正常工作，整个系统都将受到影响。<br>一旦增加新的产品，就不得不修改工厂类的逻辑，违背了“开闭原则”。</p></blockquote><h2 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h2><ul><li>当使用者只知道传入的参数，而不关心对象的创建细节时。</li><li>当工厂类负责创建的对象（产品）比较少时。</li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><blockquote><p>尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；<br>所谓原则，只是为了更好地为我们服务；<br>具体如何应用需要我们在业务实践中灵活把控。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ithinksky/java-patterns&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="重温设计模式" scheme="https://blog.ithinksky.com/categories/%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.ithinksky.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【重温设计模式】之001概述</title>
    <link href="https://blog.ithinksky.com/2020/06/01/%E3%80%90%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%B9%8B001%E6%A6%82%E8%BF%B0/"/>
    <id>https://blog.ithinksky.com/2020/06/01/【重温设计模式】之001概述/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-11-14T15:17:17.343Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><p><a href="https://github.com/ithinksky/java-patterns" target="_blank" rel="noopener">【重温设计模式系列源码】</a></p><blockquote><p>重温设计模式，温故而知新</p></blockquote><h1 id="七大基本原则"><a class="markdownIt-Anchor" href="#七大基本原则"></a> 七大基本原则</h1><h2 id="开闭原则"><a class="markdownIt-Anchor" href="#开闭原则"></a> 开闭原则</h2><blockquote><p>对扩展开放，对修改关闭。</p></blockquote><h2 id="里氏代换原则"><a class="markdownIt-Anchor" href="#里氏代换原则"></a> 里氏代换原则</h2><blockquote><p>任何基类可以出现的地方，子类一定可以出现。</p></blockquote><h2 id="依赖倒置原则"><a class="markdownIt-Anchor" href="#依赖倒置原则"></a> 依赖倒置原则</h2><blockquote><p>面向接口编程，依赖于抽象类而不是具体类。</p></blockquote><h2 id="接口隔离原则"><a class="markdownIt-Anchor" href="#接口隔离原则"></a> 接口隔离原则</h2><blockquote><p>使用多个隔离的接口，比使用单个接口好。</p></blockquote><h2 id="迪米特法则-最少知识原则"><a class="markdownIt-Anchor" href="#迪米特法则-最少知识原则"></a> 迪米特法则 （最少知识原则）</h2><blockquote><p>一个实体应该尽量减少与其他实体的相互作用，使得系统功能模块之间相对独立。<br>一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，<br>那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互</p></blockquote><h2 id="单一职责原则"><a class="markdownIt-Anchor" href="#单一职责原则"></a> 单一职责原则</h2><blockquote><p>类的职责要单一，不能将太多的职责放在一个类中</p></blockquote><h2 id="合成复用原则"><a class="markdownIt-Anchor" href="#合成复用原则"></a> 合成复用原则</h2><blockquote><p>尽量使用合成/聚合的方式，而不是使用继承。</p></blockquote><h1 id="23种常用的设计模式"><a class="markdownIt-Anchor" href="#23种常用的设计模式"></a> 23种常用的设计模式</h1><h2 id="创建型模式-5"><a class="markdownIt-Anchor" href="#创建型模式-5"></a> 创建型模式 （5）</h2><blockquote><p>将对象的创建和对象的调用分离开，调用者不用关注对象的生命周期。</p></blockquote><ul><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="结构型模式-7"><a class="markdownIt-Anchor" href="#结构型模式-7"></a> 结构型模式 （7）</h2><blockquote><p>在解决了对象的创建问题之后，对象的组成以<br>及对象之间的依赖关系。</p></blockquote><ul><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="行为型模式-11"><a class="markdownIt-Anchor" href="#行为型模式-11"></a> 行为型模式 （11）</h2><blockquote><p>在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了。</p></blockquote><ul><li>策略模式</li><li>模板方法模式</li><li>观察者模式</li><li>迭代器模式</li><li>责任链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ul><h1 id="head-first-设计模式"><a class="markdownIt-Anchor" href="#head-first-设计模式"></a> Head First 设计模式</h1><blockquote><p>学习方法</p></blockquote><p><img src="/images/designpattern/t01/study.jpg" alt="Head First 设计模式学习方法"></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><blockquote><p>尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；<br>所谓原则，只是为了更好地为我们服务；<br>具体如何应用需要我们在业务实践中灵活把控。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ithinksky/java-patterns&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="重温设计模式" scheme="https://blog.ithinksky.com/categories/%E9%87%8D%E6%B8%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.ithinksky.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【工具】之003-Windows下常用工具</title>
    <link href="https://blog.ithinksky.com/2019/12/12/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91%E4%B9%8B003-windows%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>https://blog.ithinksky.com/2019/12/12/【工具】之003-windows下常用工具/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-11-14T15:17:17.341Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><pre><code>我很懒，，，不想敲一个命令一个命令敲。。。“偷懒是有前提的，不是之前，就是之后。”</code></pre><h1 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h1><h2 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h2><h3 id="已知进程名称"><a class="markdownIt-Anchor" href="#已知进程名称"></a> 已知进程名称</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: Windows 下 杀死指定进程</span><br><span class="line">taskkill /f /t /im java.exe</span><br></pre></td></tr></table></figure><hr><h3 id="已知进程端口号"><a class="markdownIt-Anchor" href="#已知进程端口号"></a> 已知进程端口号</h3><blockquote><p>通过端口号找到对应进程 PID</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: 查找指定端口占用程序的PID</span><br><span class="line">netstat -aon | findstr "4000"</span><br></pre></td></tr></table></figure><blockquote><p>通过进程 PID 杀死指定进程</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: 通过 PID 杀死指定进程</span><br><span class="line">taskkill  /pid  1700</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面&quot;&gt;&lt;/a&gt; 写在前面&lt;/h1&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="tools" scheme="https://blog.ithinksky.com/categories/tools/"/>
    
    
      <category term="tools" scheme="https://blog.ithinksky.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>【工具】之002-Mac下常用工具</title>
    <link href="https://blog.ithinksky.com/2019/12/11/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91%E4%B9%8B002-mac%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>https://blog.ithinksky.com/2019/12/11/【工具】之002-mac下常用工具/</id>
    <published>2019-12-10T16:00:00.000Z</published>
    <updated>2020-11-14T15:17:17.341Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><pre><code>我很懒，，，不想敲一个命令一个命令敲。。。“偷懒是有前提的，不是之前，就是之后。”</code></pre><h1 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h1><h2 id="测试端口是否畅通"><a class="markdownIt-Anchor" href="#测试端口是否畅通"></a> 测试端口是否畅通</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -z 10.254.3.86 30003</span><br></pre></td></tr></table></figure><h2 id="查看端口进程pid"><a class="markdownIt-Anchor" href="#查看端口进程pid"></a> 查看端口进程PID</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:port</span><br></pre></td></tr></table></figure><h2 id="杀死进程"><a class="markdownIt-Anchor" href="#杀死进程"></a> 杀死进程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure><h2 id="杀死所有进程"><a class="markdownIt-Anchor" href="#杀死所有进程"></a> 杀死所有进程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java | grep -v grep |awk &apos;&#123;print $2&#125;&apos; | xargs kill -9</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面&quot;&gt;&lt;/a&gt; 写在前面&lt;/h1&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="tools" scheme="https://blog.ithinksky.com/categories/tools/"/>
    
    
      <category term="tools" scheme="https://blog.ithinksky.com/tags/tools/"/>
    
      <category term="mac" scheme="https://blog.ithinksky.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>【工具】之001-CentOS7 最小化安装配置</title>
    <link href="https://blog.ithinksky.com/2019/12/10/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91%E4%B9%8B001-centos7-%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.ithinksky.com/2019/12/10/【工具】之001-centos7-最小化安装配置/</id>
    <published>2019-12-09T16:00:00.000Z</published>
    <updated>2020-11-14T15:17:17.341Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --><h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><pre><code>我很懒，，，不想敲一个命令一个命令敲。。。“偷懒是有前提的，不是之前，就是之后。”</code></pre><h1 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h1><ul><li>CentOS 7 最小化安装版本：CentOS-7-x86_64-Minimal-1708</li></ul><h1 id="基础配置"><a class="markdownIt-Anchor" href="#基础配置"></a> 基础配置</h1><h2 id="配置网络"><a class="markdownIt-Anchor" href="#配置网络"></a> 配置网络</h2><ul><li>VM选择桥接</li><li>手工配置网络地址</li><li>验证可以访问外网</li></ul><p>VM克隆系统 设置静态 IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line"></span><br><span class="line">vi ifcfg-eno16777736</span><br></pre></td></tr></table></figure><p>注释掉 UUID， HWADDR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;yes&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">NAME=&quot;eno16777736&quot;</span><br><span class="line">#UUID=&quot;10f47dcb-cc95-4aad-a56c-36fe7920f431&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR0=&quot;192.168.199.200&quot;</span><br><span class="line">PREFIX0=&quot;24&quot;</span><br><span class="line">GATEWAY0=&quot;192.168.199.1&quot;</span><br><span class="line">DNS1=&quot;8.8.8.8&quot;</span><br><span class="line">DNS2=&quot;9.9.9.9&quot;</span><br><span class="line">#HWADDR=&quot;00:0C:29:E3:95:59&quot;</span><br><span class="line">IPV6_PEERDNS=&quot;yes&quot;</span><br><span class="line">IPV6_PEERROUTES=&quot;yes&quot;</span><br></pre></td></tr></table></figure><p>重启网络服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h2 id="修改主机名"><a class="markdownIt-Anchor" href="#修改主机名"></a> 修改主机名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl <span class="built_in">set</span>-hostname serverHostName</span><br></pre></td></tr></table></figure><h2 id="查询端口"><a class="markdownIt-Anchor" href="#查询端口"></a> 查询端口</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">netstat -ntlp|grep 6379</span><br></pre></td></tr></table></figure><h2 id="系统时间同步配置"><a class="markdownIt-Anchor" href="#系统时间同步配置"></a> 系统时间同步配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum install ntpdate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步时间服务器</span></span><br><span class="line">ntpdate time.nist.gov</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">ntpdate -u 0.pool.ntp.org</span><br></pre></td></tr></table></figure><p>同步时间可能有问题，参见<a href="https://blog.csdn.net/qq_27754983/article/details/69386408" target="_blank" rel="noopener">解决CentOS7下用ntpdate同步时间问题</a></p><h1 id="安装基本工具"><a class="markdownIt-Anchor" href="#安装基本工具"></a> 安装基本工具</h1><h2 id="安装net-tools"><a class="markdownIt-Anchor" href="#安装net-tools"></a> 安装net-tools</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install net-tools</span><br></pre></td></tr></table></figure><h2 id="安装-wget"><a class="markdownIt-Anchor" href="#安装-wget"></a> 安装 wget</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># -c 断点续传 ， -O 指定文件名称</span></span><br><span class="line">wget -c -O fileName url</span><br></pre></td></tr></table></figure><h2 id="安装-curl"><a class="markdownIt-Anchor" href="#安装-curl"></a> 安装 curl</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install curl</span><br></pre></td></tr></table></figure><h1 id="基本命令"><a class="markdownIt-Anchor" href="#基本命令"></a> 基本命令</h1><h2 id="查找安装路径"><a class="markdownIt-Anchor" href="#查找安装路径"></a> 查找安装路径：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure><h2 id="查找文件路径"><a class="markdownIt-Anchor" href="#查找文件路径"></a> 查找文件路径：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name nginx</span><br></pre></td></tr></table></figure><h2 id="查询nginx进程"><a class="markdownIt-Anchor" href="#查询nginx进程"></a> 查询nginx进程：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep nginx</span><br></pre></td></tr></table></figure><h2 id="查看-centos-内核版本"><a class="markdownIt-Anchor" href="#查看-centos-内核版本"></a> 查看 CentOS 内核版本：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h2 id="查看-gcc-是否安装"><a class="markdownIt-Anchor" href="#查看-gcc-是否安装"></a> 查看 gcc 是否安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep gcc</span><br></pre></td></tr></table></figure><h2 id="卸载软件"><a class="markdownIt-Anchor" href="#卸载软件"></a> 卸载软件</h2><p>需要看你的软件包格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 如果你带有yum，可以直接</span></span><br><span class="line">yum remove xxx</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果是rpm包，</span></span><br><span class="line">rpm -e xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># tar包的话需要你直接删除该文件或者</span></span><br><span class="line">make uninstall xxx</span><br></pre></td></tr></table></figure><p>卸载 Docker:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">yum list installed | grep docker </span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">yum -y remove docker.xxx.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">rm -ef /var/lib/docker</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看ip信息</span></span><br><span class="line">ip add</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示当前路径的全路径 </span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文件复制 </span></span><br><span class="line">cp -r /bashrc /bak/bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新</span></span><br><span class="line">yum update </span><br><span class="line"></span><br><span class="line">tail -f /data/logs/xxxx/xxxx.log </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文档内容</span></span><br><span class="line">cat    </span><br><span class="line"></span><br><span class="line"><span class="comment">#分页查看文档内容</span></span><br><span class="line">more   </span><br><span class="line"></span><br><span class="line"><span class="comment">#列出所有文件</span></span><br><span class="line">ls -a  </span><br><span class="line"></span><br><span class="line"><span class="comment">#拷贝文件夹及文件夹内文件</span></span><br><span class="line">cp -r tomcat-xxxx tomcat-xxxx-new   </span><br><span class="line"></span><br><span class="line"><span class="comment">#强制删除文件夹或文件</span></span><br><span class="line">rm -rf logs   </span><br><span class="line"></span><br><span class="line"><span class="comment">#清空文件内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span>&gt;catalina.out   </span><br><span class="line"></span><br><span class="line"><span class="comment">#查找文件 </span></span><br><span class="line">find / -name my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到 tomcat-x-cas-server 的进程，</span></span><br><span class="line"><span class="comment"># 第二个参数是 pid</span></span><br><span class="line"><span class="comment"># 通过 pid 杀死进程</span></span><br><span class="line">ps -ef | grep <span class="string">"tomcat-x-cas-server"</span> | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span> | xargs <span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure><h1 id="开发环境"><a class="markdownIt-Anchor" href="#开发环境"></a> 开发环境</h1><h2 id="安装-java"><a class="markdownIt-Anchor" href="#安装-java"></a> 安装 java</h2><p>1.卸载 自带的 openjdk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep java</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps java-xxx</span><br></pre></td></tr></table></figure><p>2.从 Oracle 官网下载 jdk-8u181-linux-x64.tar.gz</p><p>3.解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar –xzvf jdk-8u45-linux-x64.gz</span><br></pre></td></tr></table></figure><p>4.jdk的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=jdk的绝对路径</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br></pre></td></tr></table></figure><p>使用 <code>source /etc/profile</code> 重新加载配置，使配置生效。</p><p>或</p><p>使用<code>reboot</code>命令重启系统使环境变量生效。</p><p>5.测试安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line"></span><br><span class="line">javac</span><br></pre></td></tr></table></figure><h2 id="安装-maven"><a class="markdownIt-Anchor" href="#安装-maven"></a> 安装 Maven</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install maven</span><br></pre></td></tr></table></figure><h2 id="安装-git"><a class="markdownIt-Anchor" href="#安装-git"></a> 安装 Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># git clone --branch [tags标签] [git地址]</span></span><br></pre></td></tr></table></figure><h2 id="安装-tomcat"><a class="markdownIt-Anchor" href="#安装-tomcat"></a> 安装 tomcat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 wget 方式下载 apache-tomcat-8.5.23.tar.gz</span></span><br><span class="line">wget -c -O apache-tomcat-8.5.23.tar.gz http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.23/bin/apache-tomcat-8.5.23.tar.gz</span><br><span class="line"><span class="comment"># 解压 apache-tomcat-8.5.23.tar.gz</span></span><br><span class="line">tar -xzvf apache-tomcat-8.5.23.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 tomcat </span></span><br><span class="line">./startup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将8080端口添加到防火墙例外并重启</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="安装-mysql"><a class="markdownIt-Anchor" href="#安装-mysql"></a> 安装 MySQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 下载 mysql 的 repo 源</span></span><br><span class="line">wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"><span class="comment">#2. 安装 mysql 的 repo 源</span></span><br><span class="line">rpm -ivh mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"><span class="comment">#3. 安装 mysql</span></span><br><span class="line">yum -y install mysql-server</span><br></pre></td></tr></table></figure><p>Mysql5.7默认安装之后root是有密码的。</p><p>获取MySQL的临时密码<br>为了加强安全性，MySQL5.7为root用户随机生成了一个密码，在error log中，关于error log的位置，如果安装的是RPM包，则默认是/var/log/mysqld.log。<br>只有启动过一次mysql才可以查看临时密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看原始密码</span></span><br><span class="line">grep <span class="string">'temporary password'</span> /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#将3306端口添加到防火墙例外并重启</span></span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#修改密码</span><br><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;eFeG20125&apos;;</span><br><span class="line"></span><br><span class="line">#授权远程网络访问</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;192.168.199.%&apos; IDENTIFIED BY &apos;eFeG20125&apos; WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>MySQL 5.7.25 <a href="https://blog.csdn.net/qq_30162219/article/details/87768612" target="_blank" rel="noopener">https://blog.csdn.net/qq_30162219/article/details/87768612</a></p><h2 id="安装-redis"><a class="markdownIt-Anchor" href="#安装-redis"></a> 安装 Redis</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 设置 Redis 的仓库地址</span></span><br><span class="line">yum -y install epel-release</span><br><span class="line"><span class="comment">#2. 安装 Redis</span></span><br><span class="line">yum -y install redis</span><br><span class="line"><span class="comment">#3. redis 相关目录及文件</span></span><br><span class="line">rpm -ql redis</span><br><span class="line"></span><br><span class="line">[root[@galsang](https://my.oschina.net/u/3537623) ~]<span class="comment"># rpm -ql redis</span></span><br><span class="line">/etc/logrotate.d/redis</span><br><span class="line">/etc/redis-sentinel.conf</span><br><span class="line">/etc/redis.conf</span><br><span class="line">/etc/systemd/system/redis-sentinel.service.d</span><br><span class="line">/etc/systemd/system/redis-sentinel.service.d/limit.conf</span><br><span class="line">/etc/systemd/system/redis.service.d</span><br><span class="line">/etc/systemd/system/redis.service.d/limit.conf</span><br><span class="line">/usr/bin/redis-benchmark</span><br><span class="line">/usr/bin/redis-check-aof</span><br><span class="line">/usr/bin/redis-check-rdb</span><br><span class="line">/usr/bin/redis-cli</span><br><span class="line">/usr/bin/redis-sentinel</span><br><span class="line">/usr/bin/redis-server</span><br><span class="line">/usr/lib/systemd/system/redis-sentinel.service</span><br><span class="line">/usr/lib/systemd/system/redis.service</span><br><span class="line">/usr/libexec/redis-shutdown</span><br><span class="line">/usr/share/doc/redis-3.2.12</span><br><span class="line">/usr/share/doc/redis-3.2.12/00-RELEASENOTES</span><br><span class="line">/usr/share/doc/redis-3.2.12/BUGS</span><br><span class="line">/usr/share/doc/redis-3.2.12/CONTRIBUTING</span><br><span class="line">/usr/share/doc/redis-3.2.12/MANIFESTO</span><br><span class="line">/usr/share/doc/redis-3.2.12/README.md</span><br><span class="line">/usr/share/licenses/redis-3.2.12</span><br><span class="line">/usr/share/licenses/redis-3.2.12/COPYING</span><br><span class="line">/usr/share/man/man1/redis-benchmark.1.gz</span><br><span class="line">/usr/share/man/man1/redis-check-aof.1.gz</span><br><span class="line">/usr/share/man/man1/redis-check-rdb.1.gz</span><br><span class="line">/usr/share/man/man1/redis-cli.1.gz</span><br><span class="line">/usr/share/man/man1/redis-sentinel.1.gz</span><br><span class="line">/usr/share/man/man1/redis-server.1.gz</span><br><span class="line">/usr/share/man/man5/redis-sentinel.conf.5.gz</span><br><span class="line">/usr/share/man/man5/redis.conf.5.gz</span><br><span class="line">/var/lib/redis</span><br><span class="line">/var/<span class="built_in">log</span>/redis</span><br><span class="line">/var/run/redis</span><br></pre></td></tr></table></figure><p><a href="http://www.360doc.com/showweb/0/0/821185783.aspx" title="各个参数的含义" target="_blank" rel="noopener">各个参数的含义</a></p><h3 id="配置-redisconf"><a class="markdownIt-Anchor" href="#配置-redisconf"></a> 配置 redis.conf</h3><blockquote><p>etc/redis.conf</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#bind 127.0.0.1 </span><br><span class="line">requirepass redisPassword</span><br></pre></td></tr></table></figure><h3 id="开放-redis-端口"><a class="markdownIt-Anchor" href="#开放-redis-端口"></a> 开放 redis 端口</h3><blockquote><p>将6379端口添加到防火墙例外并重启</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><p>启动方式<br>客户端连接方式</p><h2 id="安装-nginx"><a class="markdownIt-Anchor" href="#安装-nginx"></a> 安装 Nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum -y install nginx</span><br><span class="line"></span><br><span class="line">/usr/sbin/nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 nginx 服务</span></span><br><span class="line">service nginx restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 80 端口添加到防火墙例外并重启</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="安装-rabbitmq"><a class="markdownIt-Anchor" href="#安装-rabbitmq"></a> 安装 RabbitMQ</h2><p><a href="https://www.cnblogs.com/uptothesky/p/6094357.html" title="在CentOS7上安装RabbitMQ" target="_blank" rel="noopener">在CentOS7上安装RabbitMQ</a></p><h2 id="配置swap交换区"><a class="markdownIt-Anchor" href="#配置swap交换区"></a> 配置swap交换区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 确定硬盘的最佳块大小：</span></span><br><span class="line"></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</span><br><span class="line"></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=2048 count=500000 of=/root/1Gb.file</span><br><span class="line"></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=4096 count=250000 of=/root/1Gb.file</span><br><span class="line"></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=8192 count=125000 of=/root/1Gb.file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小。</span></span><br><span class="line"> </span><br><span class="line">free -m</span><br><span class="line">df -h</span><br><span class="line"><span class="built_in">cd</span> /var</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=swapfile bs=1024 count=4096</span><br><span class="line"><span class="comment">#dd if=/dev/zero of=swapfile bs=4M count=2048</span></span><br><span class="line"></span><br><span class="line">/sbin/mkswap swapfile</span><br><span class="line">ll swapfile </span><br><span class="line">/sbin/swapon swapfile</span><br><span class="line">/sbin/swapon -s </span><br><span class="line"></span><br><span class="line">vim  /etc/fstab</span><br><span class="line">/var/swapfile swap swap defaults 0 0</span><br><span class="line"> </span><br><span class="line"><span class="comment">#停止所有的swap分区</span></span><br><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Dec 17 2020 17:40:32 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#写在前面&quot;&gt;&lt;/a&gt; 写在前面&lt;/h1&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="tools" scheme="https://blog.ithinksky.com/categories/tools/"/>
    
    
      <category term="tools" scheme="https://blog.ithinksky.com/tags/tools/"/>
    
      <category term="linux" scheme="https://blog.ithinksky.com/tags/linux/"/>
    
  </entry>
  
</feed>
