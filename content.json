{"meta":{"title":"星月楼阁","subtitle":null,"description":null,"author":"tengpeng.gao","url":"https://blog.ithinksky.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-11-14T15:17:17.338Z","updated":"2020-11-14T15:17:17.338Z","comments":false,"path":"/404.html","permalink":"https://blog.ithinksky.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-14T15:17:17.346Z","updated":"2020-11-14T15:17:17.346Z","comments":false,"path":"about/index.html","permalink":"https://blog.ithinksky.com/about/index.html","excerpt":"","text":"崇尚自由，喜欢关注新鲜事物。长期关注Java、Spring、微服务等技术栈。长期战斗在开发一线（I Love My Coding Work）。喜欢编写自动化程序、热爱开源。代码有洁癖，追求不断挑战。热爱coding，喜欢国学、动漫、旅行，，， 关于本站记录学习过程分享研究成果文哲认知过程天马行空杂谈 联系我QQ：3132670669Email：tengpeng.gao[@]gmail.com 默默耕耘温柔的久处不厌才难得"},{"title":"友情链接","date":"2020-11-14T15:17:17.348Z","updated":"2020-11-14T15:17:17.348Z","comments":true,"path":"links/index.html","permalink":"https://blog.ithinksky.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-14T15:17:17.348Z","updated":"2020-11-14T15:17:17.348Z","comments":false,"path":"categories/index.html","permalink":"https://blog.ithinksky.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-14T15:17:17.349Z","updated":"2020-11-14T15:17:17.349Z","comments":false,"path":"tags/index.html","permalink":"https://blog.ithinksky.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【解读JDK】之001-Objects类","slug":"2021/01/jdk8-001-Object","date":"2021-01-11T16:00:00.000Z","updated":"2021-01-12T14:11:03.959Z","comments":true,"path":"2021/01/12/【解读jdk】之001-objects类/","link":"","permalink":"https://blog.ithinksky.com/2021/01/12/【解读jdk】之001-objects类/","excerpt":"","text":"Objectsjdk路径： java.util.Objects 判断两个对象是否相等123456789101112131415161718/** * Returns &#123;@code true&#125; if the arguments are equal to each other * and &#123;@code false&#125; otherwise. * Consequently, if both arguments are &#123;@code null&#125;, &#123;@code true&#125; * is returned and if exactly one argument is &#123;@code null&#125;, &#123;@code * false&#125; is returned. Otherwise, equality is determined by using * the &#123;@link Object#equals equals&#125; method of the first * argument. * * @param a an object * @param b an object to be compared with &#123;@code a&#125; for equality * @return &#123;@code true&#125; if the arguments are equal to each other * and &#123;@code false&#125; otherwise * @see Object#equals(Object) */public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 判断两个对象是否深相等12345678910111213141516171819202122232425/** * Returns &#123;@code true&#125; if the arguments are deeply equal to each other * and &#123;@code false&#125; otherwise. * * Two &#123;@code null&#125; values are deeply equal. If both arguments are * arrays, the algorithm in &#123;@link Arrays#deepEquals(Object[], * Object[]) Arrays.deepEquals&#125; is used to determine equality. * Otherwise, equality is determined by using the &#123;@link * Object#equals equals&#125; method of the first argument. * * @param a an object * @param b an object to be compared with &#123;@code a&#125; for deep equality * @return &#123;@code true&#125; if the arguments are deeply equal to each other * and &#123;@code false&#125; otherwise * @see Arrays#deepEquals(Object[], Object[]) * @see Objects#equals(Object, Object) */ public static boolean deepEquals(Object a, Object b) &#123; if (a == b) return true; else if (a == null || b == null) return false; else return Arrays.deepEquals0(a, b); &#125; 比较两个对象1234567891011121314151617181920212223/** * Returns 0 if the arguments are identical and &#123;@code * c.compare(a, b)&#125; otherwise. * Consequently, if both arguments are &#123;@code null&#125; 0 * is returned. * * &lt;p&gt;Note that if one of the arguments is &#123;@code null&#125;, a &#123;@code * NullPointerException&#125; may or may not be thrown depending on * what ordering policy, if any, the &#123;@link Comparator Comparator&#125; * chooses to have for &#123;@code null&#125; values. * * @param &lt;T&gt; the type of the objects being compared * @param a an object * @param b an object to be compared with &#123;@code a&#125; * @param c the &#123;@code Comparator&#125; to compare the first two arguments * @return 0 if the arguments are identical and &#123;@code * c.compare(a, b)&#125; otherwise. * @see Comparable * @see Comparator */public static &lt;T&gt; int compare(T a, T b, Comparator&lt;? super T&gt; c) &#123; return (a == b) ? 0 : c.compare(a, b);&#125; 检测对象是否非空，为空抛出空指针异常1234567891011121314151617181920/** * Checks that the specified object reference is not &#123;@code null&#125;. This * method is designed primarily for doing parameter validation in methods * and constructors, as demonstrated below: * &lt;blockquote&gt;&lt;pre&gt; * public Foo(Bar bar) &#123; * this.bar = Objects.requireNonNull(bar); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param obj the object reference to check for nullity * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; */public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 检测对象是否非空，为空抛出空指针异常，并指定异常描述信息123456789101112131415161718192021222324/** * Checks that the specified object reference is not &#123;@code null&#125; and * throws a customized &#123;@link NullPointerException&#125; if it is. This method * is designed primarily for doing parameter validation in methods and * constructors with multiple parameters, as demonstrated below: * &lt;blockquote&gt;&lt;pre&gt; * public Foo(Bar bar, Baz baz) &#123; * this.bar = Objects.requireNonNull(bar, &quot;bar must not be null&quot;); * this.baz = Objects.requireNonNull(baz, &quot;baz must not be null&quot;); * &#125; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param obj the object reference to check for nullity * @param message detail message to be used in the event that a &#123;@code * NullPointerException&#125; is thrown * @param &lt;T&gt; the type of the reference * @return &#123;@code obj&#125; if not &#123;@code null&#125; * @throws NullPointerException if &#123;@code obj&#125; is &#123;@code null&#125; */public static &lt;T&gt; T requireNonNull(T obj, String message) &#123; if (obj == null) throw new NullPointerException(message); return obj;&#125; 检测对象是否为空1234567891011121314151617/** * Returns &#123;@code true&#125; if the provided reference is &#123;@code null&#125; otherwise * returns &#123;@code false&#125;. * * @apiNote This method exists to be used as a * &#123;@link java.util.function.Predicate&#125;, &#123;@code filter(Objects::isNull)&#125; * * @param obj a reference to be checked against &#123;@code null&#125; * @return &#123;@code true&#125; if the provided reference is &#123;@code null&#125; otherwise * &#123;@code false&#125; * * @see java.util.function.Predicate * @since 1.8 */public static boolean isNull(Object obj) &#123; return obj == null;&#125; 检测对象是否为非空1234567891011121314151617/** * Returns &#123;@code true&#125; if the provided reference is non-&#123;@code null&#125; * otherwise returns &#123;@code false&#125;. * * @apiNote This method exists to be used as a * &#123;@link java.util.function.Predicate&#125;, &#123;@code filter(Objects::nonNull)&#125; * * @param obj a reference to be checked against &#123;@code null&#125; * @return &#123;@code true&#125; if the provided reference is non-&#123;@code null&#125; * otherwise &#123;@code false&#125; * * @see java.util.function.Predicate * @since 1.8 */public static boolean nonNull(Object obj) &#123; return obj != null;&#125; 其他方法，暂略","categories":[{"name":"解读JDK","slug":"解读JDK","permalink":"https://blog.ithinksky.com/categories/解读JDK/"}],"tags":[{"name":"jdk1.8","slug":"jdk1-8","permalink":"https://blog.ithinksky.com/tags/jdk1-8/"},{"name":"java","slug":"java","permalink":"https://blog.ithinksky.com/tags/java/"}],"author":"tengpeng.gao"},{"title":"【戏说解决方案】之001网络爬虫","slug":"2020/12/scheme-001-WebCrawler","date":"2020-12-16T16:00:00.000Z","updated":"2020-12-17T10:02:02.350Z","comments":true,"path":"2020/12/17/【戏说解决方案】之001网络爬虫/","link":"","permalink":"https://blog.ithinksky.com/2020/12/17/【戏说解决方案】之001网络爬虫/","excerpt":"","text":"像安全与黑客从来都是相辅相成一样。爬虫与反爬虫也是在双方程序员的斗智斗勇的过程不断发展和成长的。 抓包抓包的目的： 分析出协议请求使用的数据，请求接口，参数等等。常用的抓包分析工具：FiddlerCharlesSnifferWireshark具体使用策略，请自行百度，Google。 抓数据 使用 HttpClient 模拟请求充分了解 HttpClient 的特性，使用方式等。HttpClient4.5官方教程 user_agent 的使用使用 user_agent 的伪装和轮换模拟不同的客户端。建立UserAgent池，可以通过以下地址获取一定量的UserAgent的信息。1http://www.fynas.com/ua/search?b=Chrome&amp;k= 代理IP的使用建立代理ip池，一般使用的免费或收费代理获取代理ip每秒都会有一定的频率限制。那么我们在使用的时候，就要在频率限制内建立自己内部的一些策略，当然这些策略建立在代理服务商的策略之上。因此设计实施时要考虑易维护性。 http代理有些网站（包括APP、PC）具有一定的反爬虫能力，如拒绝代理ip直接请求接口:这是我使用代理ip请求登录接口时，某APP的响应：1CONNECT refused by proxy而使用socks代理则无此问题。这就不得不要了解http代理和socks代理的区别。 socks代理待续 设置访问频率即便是使用了代理ip，那么对目标接口的访问也要有一定的频率控制，防止目标服务方检测出频率过快，进行拒绝服务的响应。 Cookie 池失效和更新策略获取目标站点Cookie有效时间，将对应账号和Cookie存入Redis，起一个任务对账号Cookie进行定时检测，接近失效时间，进行提前更新Cookie信息，具体Cookie 池Cookie的失效和更新策略需要根据自己业务进行适当调整。 防止目标方的分析确保同一账号的请求使用的是同一个UserAgent、同一个代理ip。注意访问频率其他总而言之，就是模拟正常的客户端发起对服务方的请求，伪装的越像正常的客户端，服务方越难分析出。只要是服务方能够提供服务，一般情况下都可以进行数据的爬取，只不过是难易程度不同。如果出于商业目的，要考虑付出的成本到底是否合适。","categories":[{"name":"戏说解决方案","slug":"戏说解决方案","permalink":"https://blog.ithinksky.com/categories/戏说解决方案/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://blog.ithinksky.com/tags/网络爬虫/"}],"author":"tengpeng.gao"},{"title":"【逻辑推理】之001拿球问题","slug":"2020/12/IQ-001-ball","date":"2020-12-16T16:00:00.000Z","updated":"2020-12-17T09:40:24.046Z","comments":true,"path":"2020/12/17/【逻辑推理】之001拿球问题/","link":"","permalink":"https://blog.ithinksky.com/2020/12/17/【逻辑推理】之001拿球问题/","excerpt":"","text":"拿球问题123问题描述：假设排列着100个乒乓球，由两个人轮流拿球装入口袋，能拿到第100个乒乓球的人为胜利者。条件是：每次拿球者至少要拿1个，但最多不能超过5个，问：如果你是最先拿球的人，你该拿几个？以后怎么拿就能保证你能得到第100个乒乓球？要想拿到第100个球，那么在上一轮的拿球中，就必须拿到第94个球； 要想拿到第94个球，那么在上一轮的拿球中，就必须拿到第88个球； 要想拿到第88个球，那么在上一轮的拿球中，就必须拿到第82个球； ………… 由于100=6*16+4，那么由此推测，在第一轮拿球过程中，必须拿4个； 在以后的拿球中必须保证拿到第10,16，……，4+6*a个球，其中1&lt;a&lt;=16. 拿球问题变式123问题描述：假设排列着100个乒乓球，由两个人轮流拿球装入口袋，能拿到第100个乒乓球的人为胜利者。条件是：每次拿球者至少要拿1个，A 只能拿1，2，3个，B只能拿1，2个，问：如果A是最先拿球的人，以后怎么拿就能保证A能得到第100个乒乓球？每回合拿球都是3的倍数，那么最后一回合时还有1个球，由于A先拿，所以A必能拿到第100个球。","categories":[{"name":"逻辑推理","slug":"逻辑推理","permalink":"https://blog.ithinksky.com/categories/逻辑推理/"}],"tags":[{"name":"逻辑推理","slug":"逻辑推理","permalink":"https://blog.ithinksky.com/tags/逻辑推理/"}],"author":"tengpeng.gao"},{"title":"【JDK1.8】java.lang.ref 包","slug":"2020/08/jdk-1.8-001-java.lang.ref","date":"2020-08-13T16:00:00.000Z","updated":"2020-11-14T15:17:17.346Z","comments":true,"path":"2020/08/14/【jdk1-8】java-lang-ref-包/","link":"","permalink":"https://blog.ithinksky.com/2020/08/14/【jdk1-8】java-lang-ref-包/","excerpt":"","text":"java.lang.ref 包【JDK1.8案例源码】Java.lang.ref 是 Java 类库中比较特殊的一个包，它提供了与 Java 垃圾回收器密切相关的引用类。reference objects are implemented in close cooperation with the garbage collector 包内结构 类图Reference 是一个抽象类，而 SoftReference，WeakReference，PhantomReference 以及 FinalReference 都是继承它的具体类。 Reference 特性及用法 StrongReference我们都知道 JVM 中对象是被分配在堆（heap）上的，当程序行动中不再有引用指向这个对象时，这个对象就可以被垃圾回收器所回收。这里所说的引用也就是我们一般意义上申明的对象类型的变量（如 String, Object, ArrayList 等），区别于原始数据类型的变量（如 int, short, long 等）也称为强引用。在了解虚引用之前，我们一般都是使用强引用来对对象进行引用。如：清单 1. StrongReference usage12String tag = new String(&quot;T&quot;);此处的 tag 引用就称之为强引用。而强引用有以下特征：强引用可以直接访问目标对象。强引用所指向的对象在任何时候都不会被系统回收。强引用可能导致内存泄漏。我们要讨论的这三种 Reference 较之于强引用而言都属于”弱引用”，也就是他们所引用的对象只要没有强引用，就会根据条件被 JVM 的垃圾回收器所回收，它们被回收的时机以及用法各不相同。下面分别来进行讨论。 SoftReferenceSoftReference 在”弱引用”中属于最强的引用。SoftReference 所指向的对象，当没有强引用指向它时，会在内存中停留一段的时间，垃圾回收器会根据 JVM 内存的使用情况（内存的紧缺程度）以及 SoftReference 的 get() 方法的调用情况来决定是否对其进行回收。具体使用一般是通过 SoftReference 的构造方法，将需要用弱引用来指向的对象包装起来。当需要使用的时候，调用 SoftReference 的 get() 方法来获取。当对象未被回收时 SoftReference 的 get() 方法会返回该对象的强引用。如下：清单 2. SoftReference usage123SoftReference&lt;Bean&gt; bean = new SoftReference&lt;Bean&gt;(new Bean(&quot;name&quot;, 10));System.out.println(bean.get());// &quot;name:10”软引用有以下特征：软引用使用 get() 方法取得对象的强引用从而访问目标对象。软引用所指向的对象按照 JVM 的使用情况（Heap 内存是否临近阈值）来决定是否回收。软引用可以避免 Heap 内存不足所导致的异常。当垃圾回收器决定对其回收时，会先清空它的 SoftReference，也就是说 SoftReference 的 get() 方法将会返回 null，然后再调用对象的 finalize() 方法，并在下一轮 GC 中对其真正进行回收。 WeakReferenceWeakReference 是弱于 SoftReference 的引用类型。弱引用的特性和基本与软引用相似，区别就在于弱引用所指向的对象只要进行系统垃圾回收，不管内存使用情况如何，永远对其进行回收（get() 方法返回 null）。完全可以通过和 SoftReference 一样的方式来操作 WeakReference，这里就不再复述。弱引用有以下特征：弱引用使用 get() 方法取得对象的强引用从而访问目标对象。一旦系统内存回收，无论内存是否紧张，弱引用指向的对象都会被回收。弱引用也可以避免 Heap 内存不足所导致的异常。 PhantomReferencePhantomReference 是所有”弱引用”中最弱的引用类型。不同于软引用和弱引用，虚引用无法通过 get() 方法来取得目标对象的强引用从而使用目标对象，观察源码可以发现 get() 被重写为永远返回 null。那虚引用到底有什么作用？其实虚引用主要被用来 跟踪对象被垃圾回收的状态 ，通过查看引用队列中是否包含对象所对应的虚引用来判断它是否 即将 被垃圾回收，从而采取行动。它并不被期待用来取得目标对象的引用，而目标对象被回收前，它的引用会被放入一个 ReferenceQueue 对象中，从而达到跟踪对象垃圾回收的作用。所以具体用法和之前两个有所不同，它必须传入一个 ReferenceQueue 对象。当虚引用所引用对象被垃圾回收后，虚引用会被添加到这个队列中。如：清单 3. PhantomReference usage1234567891011public static void main(String[] args) &#123; ReferenceQueue&lt;String&gt; refQueue = new ReferenceQueue&lt;String&gt;(); PhantomReference&lt;String&gt; referent = new PhantomReference&lt;String&gt;(new String(&quot;T&quot;), refQueue); System.out.println(referent.get());// null System.gc(); System.runFinalization(); System.out.println(refQueue.poll() == referent); //true&#125;值得注意的是，对于引用回收方面，虚引用类似强引用不会自动根据内存情况自动对目标对象回收，Client 需要自己对其进行处理以防 Heap 内存不足异常。虚引用有以下特征：虚引用永远无法使用 get() 方法取得对象的强引用从而访问目标对象。虚引用所指向的对象在被系统内存回收前，虚引用自身会被放入 ReferenceQueue 对象中从而跟踪对象垃圾回收。虚引用不会根据内存情况自动回收目标对象。另外值得注意的是，其实 SoftReference, WeakReference 以及 PhantomReference 的构造函数都可以接收一个 ReferenceQueue 对象。当 SoftReference 以及 WeakReference 被清空的同时，也就是 Java 垃圾回收器准备对它们所指向的对象进行回收时，调用对象的 finalize() 方法之前，它们自身会被加入到这个 ReferenceQueue 对象 中，此时可以通过 ReferenceQueue 的 poll() 方法取到它们。而 PhantomReference 只有当 Java 垃圾回收器对其所指向的对象真正进行回收时，会将其加入到这个 ReferenceQueue 对象 中，这样就可以追综对象的销毁情况。 各种引用类型总结 表 1. 引用类型特性总结引用类型取得目标对象方式垃圾回收条件是否可能内存泄漏强引用直接调用不回收可能软引用通过 get() 方法视内存情况回收可能弱引用通过 get() 方法永远回收可能虚引用无法取得不回收可能注意： 如果想使用这些相对强引用来说较弱的引用来进行对象操作的时候， 就必须保证没有强引用指向被操作对象。否则将会被视为强引用指向， 不会具有任何的弱引用的特性。 表 2：各个引用在 GC 后是否被回收？引用类型GC 后是否回收强引用不回收软引用视内存情况回收弱引用永远回收虚引用不回收 表 3：各个引用创建大量对象时是否导致 Heap 不足异常？引用类型是否抛出异常强引用直接调用软引用通过 get() 方法弱引用通过 get() 方法虚引用无法取得 FinalReference 以及 FinzlizerFinalReference 作为 java.lang.ref 里的一个不能被公开访问的类， 又起到了一个什么样的作用呢？作为他的子类， Finalizer 又在垃圾回收机制里扮演了怎么样的角色呢？ 实际上，FinalReference 代表的正是 Java 中的强引用，如这样的代码 :1Bean bean = new Bean();在虚拟机的实现过程中，实际采用了 FinalReference 类对其进行引用。而 Finalizer，除了作为一个实现类外，更是在虚拟机中实现一个 FinalizerThread，以使虚拟机能够在所有的强引用被解除后实现内存清理。让我们来看看 Finalizer 是如何工作的。首先，通过声明 FinalizerThread，并将该线程实例化，设置为守护线程后，加入系统线程中去。在 GC 的过程中，当一个强引用被释放，由系统垃圾收集器标记后的对象，会被加入 Finalizer 对象中的 ReferenceQueue 中去，并调用 Finalizer.runFinalizer() 来执行对象的 finalize 方法。注意，标记处所调用的 invokeFinalizeMethod 为 native 方法，由于 finalize 方法在 Object 类中被声明为 protected，这里必须采用 native 方法才能调用。随后通过将本地强引用设置为空，以便使垃圾回收器清理内存。可以看到，通过这样的方法，Java 将四种引用对象类型：软引用 (SoftReference)，弱引用 (WeakReference)，强引用 (FinalReference)，虚引用 (PhantomReference) 平等地对待，并在垃圾回收器中进行统一调度和管理。 回顾软引用 (SoftReference)引用类型表现为当内存接近满负荷 , 或对象由 SoftReference.get() 方法的调用没有发生一段时间后 , 垃圾回收器将会清理该对象 . 在运行对象的 finalize 方法前 , 会将软引用对象加入 ReferenceQueue 中去 .弱引用 (WeakReference)引用类型表现为当系统垃圾回收器开始回收时 , 则立即会回收该对象的引用 . 与软引用一样 , 弱引用也会在运行对象的 finalize 方法之前将弱引用对象加入 ReferenceQueue.强引用 (FinalReference)这是最常用的引用类型 . JVM 系统采用 Finalizer 来管理每个强引用对象 , 并将其被标记要清理时加入 ReferenceQueue, 并逐一调用该对象的 finalize() 方法 .虚引用 (PhantomReference)这是一个最虚幻的引用类型 . 无论是从哪里都无法再次返回被虚引用所引用的对象 . 虚引用在系统垃圾回收器开始回收对象时 , 将直接调用 finalize() 方法 , 但不会立即将其加入回收队列 . 只有在真正对象被 GC 清除时 , 才会将其加入 Reference 队列中去 . 参考深入探讨 java.lang.ref 包","categories":[{"name":"JDK1.8","slug":"JDK1-8","permalink":"https://blog.ithinksky.com/categories/JDK1-8/"}],"tags":[{"name":"JDK1.8","slug":"JDK1-8","permalink":"https://blog.ithinksky.com/tags/JDK1-8/"}],"author":"tengpeng.gao"},{"title":"【重温设计模式】之005单例模式","slug":"2020/06/java-patterns-005-singleton","date":"2020-06-17T16:00:00.000Z","updated":"2020-11-14T15:17:17.345Z","comments":true,"path":"2020/06/18/【重温设计模式】之005单例模式/","link":"","permalink":"https://blog.ithinksky.com/2020/06/18/【重温设计模式】之005单例模式/","excerpt":"","text":"【重温设计模式系列源码】单例模式 基本原理 含义一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，访问者可以直接访问，不需要实例化该类的对象。 解决的问题保证一个类仅有一个实例，并提供一个访问它的全局访问点。一个全局使用的类频繁地创建与销毁。 组成部分单例类只能有一个实例类对象的实例数： 0 ~ 1单例类必须自己创建自己的唯一实例类的构造方法：私有构造方法。单例类必须给所有其他对象提供这一实例提供唯一的访问该对象实例的方法。 UML类图 使用步骤访问唯一的访问该对象实例的方法 优点在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。避免对资源的多重占用（比如写文件操作）。 缺点没有接口，不能继承，违背了单一职责原则一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 适用场景要求生产唯一序列号。WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 总结尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；所谓原则，只是为了更好地为我们服务；具体如何应用需要我们在业务实践中灵活把控。","categories":[{"name":"重温设计模式","slug":"重温设计模式","permalink":"https://blog.ithinksky.com/categories/重温设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.ithinksky.com/tags/设计模式/"}],"author":"tengpeng.gao"},{"title":"【重温设计模式】之004抽象工厂模式","slug":"2020/06/java-patterns-004-abstractfactory","date":"2020-06-16T16:00:00.000Z","updated":"2020-11-14T15:17:17.344Z","comments":true,"path":"2020/06/17/【重温设计模式】之004抽象工厂模式/","link":"","permalink":"https://blog.ithinksky.com/2020/06/17/【重温设计模式】之004抽象工厂模式/","excerpt":"","text":"【重温设计模式系列源码】抽象工厂模式 基本原理 含义抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。 解决的问题即工厂方法模式的缺点: 每个工厂只能创建一类产品 组成部分组成关系作用抽象产品（IProduct）产品顶级抽象父类描述产品的公共接口抽象子产品（IxxProduct）具体产品类的父类，顶级抽象父类的子类描述相对具体的抽象产品的公共接口具体产品（XxProduct）具体产品类，抽象父类的子类描述具体的产品抽象工厂（Factory）具体工厂的父类描述工厂的公共接口具体工厂（XxFactory）具体工厂类，抽象工厂的子类描述具体工厂 UML类图 使用步骤创建产品标准创建产品抽象类（一系列相关的产品）创建具体产品类创建工厂标准创建生产具体产品的工厂 优点低耦合将具体产品的创建延迟到子类。更符合开闭原则新增系列相关产品时，只需要增加具体的工厂和工厂需要生产的具体产品即可。符合单一职责原则，每个具体工厂类只负责创建对应的产品 缺点抽象工厂模式很难支持新种类产品的变化。这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。 适用场景一个系统不依赖产品类实例的创建和组合。这个系统有多个系列的产品，而系统中只能消费其中的一系列产品。系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。 总结尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；所谓原则，只是为了更好地为我们服务；具体如何应用需要我们在业务实践中灵活把控。","categories":[{"name":"重温设计模式","slug":"重温设计模式","permalink":"https://blog.ithinksky.com/categories/重温设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.ithinksky.com/tags/设计模式/"}],"author":"tengpeng.gao"},{"title":"【重温设计模式】之003工厂方法模式","slug":"2020/06/java-patterns-003-factorymethod","date":"2020-06-09T16:00:00.000Z","updated":"2020-11-14T15:17:17.344Z","comments":true,"path":"2020/06/10/【重温设计模式】之003工厂方法模式/","link":"","permalink":"https://blog.ithinksky.com/2020/06/10/【重温设计模式】之003工厂方法模式/","excerpt":"","text":"【重温设计模式系列源码】工厂方法模式 基本原理 含义工厂方法模式又称为工厂模式、多态工厂模式和虚拟构造器模式。通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。 解决的问题即简单工厂模式的缺点工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则言外意：工厂标准有了，产品标准有了，要想生产新的商品，需要开辟新的工厂生产新的商品。虽然解决了简单工厂模式的“开闭原则”问题，但同时增加了额外开销。简单工厂模式 是一个单一的工厂，如果需要提供新的产品，需要将工厂进行改造，可以认为需要扩展一条流水线. 资源利用率的把控 凡事皆有度。 组成部分组成关系作用产品标准具体产品的父类描述产品的公共接口具体产品产品标准的具体实现类描述生产的具体产品工厂标准具体工厂的父类描述工厂的公共接口具体工厂工厂标准的具体实现类描述生产的具体产品的工厂 UML类图 使用步骤创建产品标准 （描述产品的公共接口）创建具体产品类 （描述生产的具体产品）创建工厂标准（描述工厂的公共接口）创建具体工厂类（描述生产的具体产品的工厂）外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例 优点更符合开-闭原则新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可符合单一职责原则每个具体工厂类只负责创建对应的产品 缺点添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；一个具体工厂只能创建一种具体产品 适用场景当一个类不知道它所需要的对象的类时在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；当一个类希望通过其子类来指定创建对象时在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。灵活配置将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 总结尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；所谓原则，只是为了更好地为我们服务；具体如何应用需要我们在业务实践中灵活把控。","categories":[{"name":"重温设计模式","slug":"重温设计模式","permalink":"https://blog.ithinksky.com/categories/重温设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.ithinksky.com/tags/设计模式/"}],"author":"tengpeng.gao"},{"title":"【重温设计模式】之002简单工厂模式","slug":"2020/06/java-patterns-002-simplefactory","date":"2020-06-02T16:00:00.000Z","updated":"2020-11-14T15:17:17.343Z","comments":true,"path":"2020/06/03/【重温设计模式】之002简单工厂模式/","link":"","permalink":"https://blog.ithinksky.com/2020/06/03/【重温设计模式】之002简单工厂模式/","excerpt":"","text":"【重温设计模式系列源码】简单工厂模式 基本原理 含义简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法）。在现实生活中，工厂是生产产品的，同样的，在设计模式中，一个负责生产“对象”产品的类就是工厂类。 解决的问题将 “类实例化的操作” 和 “使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类。言外意：将 铅笔的生产 和 使用铅笔 分开， 使用者只关注如何使用铅笔，而并不关注铅笔是如何生产的。即使用者可直接消费产品而不需要知道其生产的细节。 组成部分组成关系作用产品标准具体产品的父类描述产品的公共接口具体产品产品标准的具体实现类描述生产的具体产品工厂类被外界调用根据传入的不同参数而创建不同具体产品类的实例 UML类图 使用步骤创建产品标准 （描述产品的公共接口）创建具体产品类 （描述生产的具体产品）创建工厂类（通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例）外界通过调用工厂类的静态方法，根据传入不同参数从而创建不同具体产品类的实例 优点将 创建产品的工作 与 使用产品的工作 分离开来，实现了解耦。将 初始化实例的工作 放在了工厂类进行，容易进行维护。面向接口编程，而不是面向对象。 缺点工厂类集中了所有实例（产品）的创建逻辑，一旦工厂类不能正常工作，整个系统都将受到影响。一旦增加新的产品，就不得不修改工厂类的逻辑，违背了“开闭原则”。 适用场景当使用者只知道传入的参数，而不关心对象的创建细节时。当工厂类负责创建的对象（产品）比较少时。 总结尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；所谓原则，只是为了更好地为我们服务；具体如何应用需要我们在业务实践中灵活把控。","categories":[{"name":"重温设计模式","slug":"重温设计模式","permalink":"https://blog.ithinksky.com/categories/重温设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.ithinksky.com/tags/设计模式/"}],"author":"tengpeng.gao"},{"title":"【重温设计模式】之001概述","slug":"2020/06/java-patterns-001-guide","date":"2020-05-31T16:00:00.000Z","updated":"2020-11-14T15:17:17.343Z","comments":true,"path":"2020/06/01/【重温设计模式】之001概述/","link":"","permalink":"https://blog.ithinksky.com/2020/06/01/【重温设计模式】之001概述/","excerpt":"","text":"【重温设计模式系列源码】重温设计模式，温故而知新 七大基本原则 开闭原则对扩展开放，对修改关闭。 里氏代换原则任何基类可以出现的地方，子类一定可以出现。 依赖倒置原则面向接口编程，依赖于抽象类而不是具体类。 接口隔离原则使用多个隔离的接口，比使用单个接口好。 迪米特法则 （最少知识原则）一个实体应该尽量减少与其他实体的相互作用，使得系统功能模块之间相对独立。一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互 单一职责原则类的职责要单一，不能将太多的职责放在一个类中 合成复用原则尽量使用合成/聚合的方式，而不是使用继承。 23种常用的设计模式 创建型模式 （5）将对象的创建和对象的调用分离开，调用者不用关注对象的生命周期。工厂方法模式抽象工厂模式单例模式原型模式建造者模式 结构型模式 （7）在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系。适配器模式装饰器模式代理模式外观模式桥接模式组合模式享元模式 行为型模式 （11）在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了。策略模式模板方法模式观察者模式迭代器模式责任链模式命令模式备忘录模式状态模式访问者模式中介者模式解释器模式 Head First 设计模式学习方法 总结尽信书不如无书，任何脱离实际业务的架构都是在耍流氓；所谓原则，只是为了更好地为我们服务；具体如何应用需要我们在业务实践中灵活把控。","categories":[{"name":"重温设计模式","slug":"重温设计模式","permalink":"https://blog.ithinksky.com/categories/重温设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.ithinksky.com/tags/设计模式/"}],"author":"tengpeng.gao"},{"title":"【工具】之003-Windows下常用工具","slug":"2019/12/tools-003-windows-guide","date":"2019-12-11T16:00:00.000Z","updated":"2020-11-14T15:17:17.341Z","comments":true,"path":"2019/12/12/【工具】之003-windows下常用工具/","link":"","permalink":"https://blog.ithinksky.com/2019/12/12/【工具】之003-windows下常用工具/","excerpt":"","text":"写在前面我很懒，，，不想敲一个命令一个命令敲。。。 “偷懒是有前提的，不是之前，就是之后。” 常用命令 Windows 已知进程名称12:: Windows 下 杀死指定进程taskkill /f /t /im java.exe 已知进程端口号通过端口号找到对应进程 PID12:: 查找指定端口占用程序的PIDnetstat -aon | findstr \"4000\"通过进程 PID 杀死指定进程12:: 通过 PID 杀死指定进程taskkill /pid 1700","categories":[{"name":"tools","slug":"tools","permalink":"https://blog.ithinksky.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.ithinksky.com/tags/tools/"}],"author":"tengpeng.gao"},{"title":"【工具】之002-Mac下常用工具","slug":"2019/12/tools-002-mac-guide","date":"2019-12-10T16:00:00.000Z","updated":"2020-11-14T15:17:17.341Z","comments":true,"path":"2019/12/11/【工具】之002-mac下常用工具/","link":"","permalink":"https://blog.ithinksky.com/2019/12/11/【工具】之002-mac下常用工具/","excerpt":"","text":"写在前面我很懒，，，不想敲一个命令一个命令敲。。。 “偷懒是有前提的，不是之前，就是之后。” 常用命令 测试端口是否畅通1nc -z 10.254.3.86 30003 查看端口进程PID1lsof -i:port 杀死进程1kill -9 pid 杀死所有进程1ps -ef | grep java | grep -v grep |awk &apos;&#123;print $2&#125;&apos; | xargs kill -9","categories":[{"name":"tools","slug":"tools","permalink":"https://blog.ithinksky.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.ithinksky.com/tags/tools/"},{"name":"mac","slug":"mac","permalink":"https://blog.ithinksky.com/tags/mac/"}],"author":"tengpeng.gao"},{"title":"【工具】之001-CentOS7 最小化安装配置","slug":"2019/12/tools-001-CentOS-7-x86_64-Minimal","date":"2019-12-09T16:00:00.000Z","updated":"2020-11-14T15:17:17.341Z","comments":true,"path":"2019/12/10/【工具】之001-centos7-最小化安装配置/","link":"","permalink":"https://blog.ithinksky.com/2019/12/10/【工具】之001-centos7-最小化安装配置/","excerpt":"","text":"写在前面我很懒，，，不想敲一个命令一个命令敲。。。 “偷懒是有前提的，不是之前，就是之后。” 简述CentOS 7 最小化安装版本：CentOS-7-x86_64-Minimal-1708 基础配置 配置网络VM选择桥接手工配置网络地址验证可以访问外网VM克隆系统 设置静态 IP1234cd /etc/sysconfig/network-scripts/vi ifcfg-eno16777736注释掉 UUID， HWADDR1234567891011121314151617181920TYPE=&quot;Ethernet&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;yes&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;NAME=&quot;eno16777736&quot;#UUID=&quot;10f47dcb-cc95-4aad-a56c-36fe7920f431&quot;ONBOOT=&quot;yes&quot;IPADDR0=&quot;192.168.199.200&quot;PREFIX0=&quot;24&quot;GATEWAY0=&quot;192.168.199.1&quot;DNS1=&quot;8.8.8.8&quot;DNS2=&quot;9.9.9.9&quot;#HWADDR=&quot;00:0C:29:E3:95:59&quot;IPV6_PEERDNS=&quot;yes&quot;IPV6_PEERROUTES=&quot;yes&quot;重启网络服务1service network restart 修改主机名1hostnamectl set-hostname serverHostName 查询端口12netstat -ntlp|grep 6379 系统时间同步配置1234567yum install ntpdate# 同步时间服务器ntpdate time.nist.gov# 或ntpdate -u 0.pool.ntp.org同步时间可能有问题，参见解决CentOS7下用ntpdate同步时间问题 安装基本工具 安装net-tools1yum -y install net-tools 安装 wget1234yum -y install wget# -c 断点续传 ， -O 指定文件名称wget -c -O fileName url 安装 curl1yum -y install curl 基本命令 查找安装路径：1whereis nginx 查找文件路径：1find / -name nginx 查询nginx进程：1ps aux|grep nginx 查看 CentOS 内核版本：1uname -r 查看 gcc 是否安装1rpm -qa|grep gcc 卸载软件需要看你的软件包格式：123456789# 如果你带有yum，可以直接yum remove xxx # 如果是rpm包，rpm -e xxx# tar包的话需要你直接删除该文件或者make uninstall xxx卸载 Docker:12345678910# 查看yum list installed | grep docker # 卸载yum -y remove docker.xxx.x86_64# 删除rm -ef /var/lib/docker123456789101112131415161718192021222324252627282930313233343536373839#查看ip信息ip add#显示当前路径的全路径 pwd#文件复制 cp -r /bashrc /bak/bashrc#更新yum update tail -f /data/logs/xxxx/xxxx.log #查看文档内容cat #分页查看文档内容more #列出所有文件ls -a #拷贝文件夹及文件夹内文件cp -r tomcat-xxxx tomcat-xxxx-new #强制删除文件夹或文件rm -rf logs #清空文件内容echo \"\"&gt;catalina.out #查找文件 find / -name my.cnf# 找到 tomcat-x-cas-server 的进程，# 第二个参数是 pid# 通过 pid 杀死进程ps -ef | grep \"tomcat-x-cas-server\" | grep -v grep | awk '&#123;print $2&#125;' | xargs kill -9 开发环境 安装 java1.卸载 自带的 openjdk123rpm -qa|grep javarpm -e --nodeps java-xxx2.从 Oracle 官网下载 jdk-8u181-linux-x64.tar.gz3.解压1tar –xzvf jdk-8u45-linux-x64.gz4.jdk的配置1vi /etc/profile123export JAVA_HOME=jdk的绝对路径export PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar使用 source /etc/profile 重新加载配置，使配置生效。或使用reboot命令重启系统使环境变量生效。5.测试安装是否成功123java -versionjavac 安装 Maven1yum -y install maven 安装 Git123yum -y install git# git clone --branch [tags标签] [git地址] 安装 tomcat1234567891011# 通过 wget 方式下载 apache-tomcat-8.5.23.tar.gzwget -c -O apache-tomcat-8.5.23.tar.gz http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.23/bin/apache-tomcat-8.5.23.tar.gz# 解压 apache-tomcat-8.5.23.tar.gztar -xzvf apache-tomcat-8.5.23.tar.gz# 启动 tomcat ./startup.sh# 将8080端口添加到防火墙例外并重启firewall-cmd --zone=public --add-port=8080/tcp --permanentfirewall-cmd --reload 安装 MySQL123456#1. 下载 mysql 的 repo 源wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm#2. 安装 mysql 的 repo 源rpm -ivh mysql57-community-release-el7-8.noarch.rpm#3. 安装 mysqlyum -y install mysql-serverMysql5.7默认安装之后root是有密码的。获取MySQL的临时密码为了加强安全性，MySQL5.7为root用户随机生成了一个密码，在error log中，关于error log的位置，如果安装的是RPM包，则默认是/var/log/mysqld.log。只有启动过一次mysql才可以查看临时密码123456#查看原始密码grep 'temporary password' /var/log/mysqld.log#将3306端口添加到防火墙例外并重启firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload1234567#修改密码ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;eFeG20125&apos;;#授权远程网络访问GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;192.168.199.%&apos; IDENTIFIED BY &apos;eFeG20125&apos; WITH GRANT OPTION;flush privileges;MySQL 5.7.25 https://blog.csdn.net/qq_30162219/article/details/87768612 安装 Redis12345678910111213141516171819202122232425262728293031323334353637383940414243#1. 设置 Redis 的仓库地址yum -y install epel-release#2. 安装 Redisyum -y install redis#3. redis 相关目录及文件rpm -ql redis[root[@galsang](https://my.oschina.net/u/3537623) ~]# rpm -ql redis/etc/logrotate.d/redis/etc/redis-sentinel.conf/etc/redis.conf/etc/systemd/system/redis-sentinel.service.d/etc/systemd/system/redis-sentinel.service.d/limit.conf/etc/systemd/system/redis.service.d/etc/systemd/system/redis.service.d/limit.conf/usr/bin/redis-benchmark/usr/bin/redis-check-aof/usr/bin/redis-check-rdb/usr/bin/redis-cli/usr/bin/redis-sentinel/usr/bin/redis-server/usr/lib/systemd/system/redis-sentinel.service/usr/lib/systemd/system/redis.service/usr/libexec/redis-shutdown/usr/share/doc/redis-3.2.12/usr/share/doc/redis-3.2.12/00-RELEASENOTES/usr/share/doc/redis-3.2.12/BUGS/usr/share/doc/redis-3.2.12/CONTRIBUTING/usr/share/doc/redis-3.2.12/MANIFESTO/usr/share/doc/redis-3.2.12/README.md/usr/share/licenses/redis-3.2.12/usr/share/licenses/redis-3.2.12/COPYING/usr/share/man/man1/redis-benchmark.1.gz/usr/share/man/man1/redis-check-aof.1.gz/usr/share/man/man1/redis-check-rdb.1.gz/usr/share/man/man1/redis-cli.1.gz/usr/share/man/man1/redis-sentinel.1.gz/usr/share/man/man1/redis-server.1.gz/usr/share/man/man5/redis-sentinel.conf.5.gz/usr/share/man/man5/redis.conf.5.gz/var/lib/redis/var/log/redis/var/run/redis各个参数的含义 配置 redis.confetc/redis.conf12#bind 127.0.0.1 requirepass redisPassword 开放 redis 端口将6379端口添加到防火墙例外并重启12firewall-cmd --zone=public --add-port=6379/tcp --permanentfirewall-cmd --reload 启动启动方式客户端连接方式 安装 Nginx1234567891011yum -y install nginx/usr/sbin/nginx -s reload# 重启 nginx 服务service nginx restart# 将 80 端口添加到防火墙例外并重启firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --reload 安装 RabbitMQ在CentOS7上安装RabbitMQ 配置swap交换区1234567891011121314151617181920212223242526272829# 确定硬盘的最佳块大小：dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.filedd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.filedd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.filedd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file# 通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小。 free -mdf -hcd /vardd if=/dev/zero of=swapfile bs=1024 count=4096#dd if=/dev/zero of=swapfile bs=4M count=2048/sbin/mkswap swapfilell swapfile /sbin/swapon swapfile/sbin/swapon -s vim /etc/fstab/var/swapfile swap swap defaults 0 0 #停止所有的swap分区swapoff -a","categories":[{"name":"tools","slug":"tools","permalink":"https://blog.ithinksky.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.ithinksky.com/tags/tools/"},{"name":"linux","slug":"linux","permalink":"https://blog.ithinksky.com/tags/linux/"}],"author":"tengpeng.gao"}],"categories":[{"name":"解读JDK","slug":"解读JDK","permalink":"https://blog.ithinksky.com/categories/解读JDK/"},{"name":"戏说解决方案","slug":"戏说解决方案","permalink":"https://blog.ithinksky.com/categories/戏说解决方案/"},{"name":"逻辑推理","slug":"逻辑推理","permalink":"https://blog.ithinksky.com/categories/逻辑推理/"},{"name":"JDK1.8","slug":"JDK1-8","permalink":"https://blog.ithinksky.com/categories/JDK1-8/"},{"name":"重温设计模式","slug":"重温设计模式","permalink":"https://blog.ithinksky.com/categories/重温设计模式/"},{"name":"tools","slug":"tools","permalink":"https://blog.ithinksky.com/categories/tools/"}],"tags":[{"name":"jdk1.8","slug":"jdk1-8","permalink":"https://blog.ithinksky.com/tags/jdk1-8/"},{"name":"java","slug":"java","permalink":"https://blog.ithinksky.com/tags/java/"},{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://blog.ithinksky.com/tags/网络爬虫/"},{"name":"逻辑推理","slug":"逻辑推理","permalink":"https://blog.ithinksky.com/tags/逻辑推理/"},{"name":"JDK1.8","slug":"JDK1-8","permalink":"https://blog.ithinksky.com/tags/JDK1-8/"},{"name":"设计模式","slug":"设计模式","permalink":"https://blog.ithinksky.com/tags/设计模式/"},{"name":"tools","slug":"tools","permalink":"https://blog.ithinksky.com/tags/tools/"},{"name":"mac","slug":"mac","permalink":"https://blog.ithinksky.com/tags/mac/"},{"name":"linux","slug":"linux","permalink":"https://blog.ithinksky.com/tags/linux/"}]}